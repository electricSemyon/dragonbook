## 2.2 Определение синтаксиса

### 2.2.1
```
S -> S S + | S S * | a
```

##### 1. Покажите как данная грамматика генерирует строку аа+а*
##### 2. Постройте дерево разбора для данной строки

```
    S    S    *
   /      \
 S S +     a
 | |
 a a
```
##### 3. Какой язык генерирует грамматика?
Грамматика генерирует язык, состоящий из терминалов "а" и "+", нетерминалы "S" могут выглядеть как продукции "S S +" и "S S *"

### 2.2.2

Какой язык генериуется каждой из следующих грамматик:

##### a) S -> 0 S 1 | 0 1
  Грамматика генерирует выражения вида 000111, так как в конечном итоге при разворачивании нетерминала S будет получено терминальное выражение "01". Наример 0 S 1 -> 0 0 S 1 1 -> 0 0 0 1 1 1
##### b) S -> + S S | - S S | a
  Грамматика генерирует префиксную запись вида -a-aa
##### c) S -> S ( S ) S
  Грамматика генерирует набор сбаллансированный скобок. Например: S ( S ) S -> () ( S ) -> () ( () ( () ) )
##### d) S -> aSbS | bSaS | є
  Грамматика генерирует строку вида ababaabb
##### e) S -> a | S + S | S S | S * | (S)
  Грамматика генерирует регулярные выражения для описания регулярных языков (подсмотрел [здесь](https://github.com/fool2fish/dragon-book-exercise-answers/blob/master/ch02/2.2/2.2.md)). Например: S S -> S + S (S) -> S + S S (S *) -> a+aa(a*)


### 2.2.3
##### Какие из грамматик в упражнении 2.2.2 неоднозначны?
В информатике неоднозначной грамматикой называется формальная грамматика, которая может породить некоторую строку более чем одним способом (то есть для строки есть более одного дерева разбора).

Неоднозначными грамматиками являются:
- c - строка "() ()" может быть интерпритирована как S=() (S=є) S=є, или как S=є (S=є) S=()

### 2.2.4
Постройте однозначные контекстно-свободные грамматики для каждого из следующих языков. В каждом случае покажите корректность грамматики.

##### Арифметические выражения в постфиксной записи
```
expr -> expr expr op | num
op -> + | - | * | /
```

##### Левоассоциативный список идентификаторов, разделенный запятыми
```
list -> list | list , id
```

##### Правоассоциативный список идентификаторов, разделенный запятыми
```
list -> id , list | id
```

##### Арифметические выражения, состоящие из целых чисел и идентификаторов с четырьмя бинарными операторами
```
expr -> term + expr | term - expr | term 
term -> factor * term | factor / term | factor
factor -> num | identifier
```

##### ! Добавьте унарные "плюс и минус" к арифметическим операторам из примера выше
```
expr -> term + expr | term - expr | term 
term -> factor * term | factor / term | - factor | + factor | factor
factor -> num | identifier
```
