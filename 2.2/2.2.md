## 2.2 Определение синтаксиса

### 2.2.1
```
S -> S S + | S S * | a
```

##### 1. Покажите как данная грамматика генерирует строку аа+а*
##### 2. Постройте дерево разбора для данной строки

```
    S    S    *
   /      \
 S S +     a
 | |
 a a
```
##### 3. Какой язык генерирует грамматика?
Грамматика генерирует язык, состоящий из терминалов "а" и "+", нетерминалы "S" могут выглядеть как продукции "S S +" и "S S *"

### 2.2.2

Какой язык генериуется каждой из следующих грамматик:

##### a) S -> 0 S 1 | 0 1
  Грамматика генерирует выражения вида 000111, так как в конечном итоге при разворачивании нетерминала S будет получено терминальное выражение "01". Наример 0 S 1 -> 0 0 S 1 1 -> 0 0 0 1 1 1
##### b) S -> + S S | - S S | a
  Грамматика генерирует префиксную запись вида -a-aa
##### c) S -> S ( S ) S
  Грамматика генерирует набор сбаллансированный скобок. Например: S ( S ) S -> () ( S ) -> () ( () ( () ) )
##### d) S -> aSbS | bSaS | є
  Грамматика генерирует строку вида ababaabb
##### e) S -> a | S + S | S S | S * | (S)
  Грамматика генерирует регулярные выражения для описания регулярных языков (подсмотрел [здесь](https://github.com/fool2fish/dragon-book-exercise-answers/blob/master/ch02/2.2/2.2.md)). Например: S S -> S + S (S) -> S + S S (S *) -> a+aa(a*)


### 2.2.3
##### Какие из грамматик в упражнении 2.2.2 неоднозначны?
В информатике неоднозначной грамматикой называется формальная грамматика, которая может породить некоторую строку более чем одним способом (то есть для строки есть более одного дерева разбора).

Неоднозначными грамматиками являются:
- c - строка "() ()" может быть интерпритирована как S=() (S=є) S=є, или как S=є (S=є) S=()

### 2.2.4
Постройте однозначные контекстно-свободные грамматики для каждого из следующих языков. В каждом случае покажите корректность грамматики.

##### Арифметические выражения в постфиксной записи
```
expr -> expr expr op | num
op -> + | - | * | /
```

##### Левоассоциативный список идентификаторов, разделенный запятыми
```
list -> list | list , id
```

##### Правоассоциативный список идентификаторов, разделенный запятыми
```
list -> id , list | id
```

##### Арифметические выражения, состоящие из целых чисел и идентификаторов с четырьмя бинарными операторами
```
expr -> term + expr | term - expr | term 
term -> factor * term | factor / term | factor
factor -> num | identifier
```

##### ! Добавьте унарные "плюс и минус" к арифметическим операторам из примера выше
```
expr -> term + expr | term - expr | term 
term -> factor * term | factor / term | - factor | + factor | factor
factor -> num | identifier
```

### 2.2.5
##### Покажите что все бинарные строки, генерируемые данной грамматикой, имеют значения, делаящиеся на 3. Указание: воспользуйтесь индукцией по количеству узлов в дереве разбора.
```
num -> 11 | 1001 | num 0 | num num
```
TODO
##### Генерирует ли грамматика все бинарные строки, значения которых делятся на 3?
TODO

### 2.2.6
##### Постройте контекстно свободную грамматику для записи чисел римскими цифрами
Реализовано подмножество чисел (до 30), записываемых римскими цифрами, а то там охуеть можно если попытаться описать всё. ([Вот тут почитать можно](https://ru.wikipedia.org/wiki/%D0%A0%D0%B8%D0%BC%D1%81%D0%BA%D0%B8%D0%B5_%D1%86%D0%B8%D1%84%D1%80%D1%8B))

TODO - improve solution
```
one -> I
five -> V
ten -> X | є

one_three -> one | one one | one one one | є
four -> one five
five_nine -> five one_three | one ten
one_ten -> one_three | four | five_nine

twenty = ten ten
thirty = ten ten ten

ten_thirty -> ten | twenty | thirty
ten_thirty_with_digits -> ten_thirty one_ten
```
